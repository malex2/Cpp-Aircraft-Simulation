//  Created by Alexander McLean on 08/09/19.//  Copyright Â© 2019 Alexander McLean. All rights reserved.#include <iostream>#include <chrono>#include <math.h>#include "RotateFrame.hpp"#include "AtmosphericModel.hpp"#include "GroundModel.hpp"#include "DynamicsModel.hpp"#include "AeroModel.hpp"#include "InitialConditions.h"AeroModel        aeroModel;GroundModel      groundModel;DynamicsModel    dynamicsModel;AtmosphericModel atmosphere;RotateFrame      rotate;int main() {        // Initialize body frame    rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, velBody, velNED);    rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, pqr, omega);    updateBodyStates();        // Initialize alpha and beta    aeroModel.Angles(velBody);    updateAeroAngles();    // Start realtime clock    std::chrono::time_point<std::chrono::system_clock> startTime, curTime, lastPrintTime, lastDynamicTime;    startTime        = std::chrono::system_clock::now();    lastPrintTime    = startTime;    lastDynamicTime  = startTime;        while(continueSim){                // Evaluate Time Elapsed        curTime = std::chrono::system_clock::now();        std::chrono::duration<double> timeSinceStart        = curTime - startTime;        std::chrono::duration<double> timeSinceLastPrint    = curTime - lastPrintTime;        std::chrono::duration<double> timeSinceLastDynamics = curTime - lastDynamicTime;                if (timeSinceStart.count() >= runTime) {            continueSim = false;        }                // Print stuff        if (timeSinceLastDynamics.count() >= dynamicsInterval){            // do stuff            lastDynamicTime = std::chrono::system_clock::now();        }                // Print stuff        if (timeSinceLastPrint.count() >= printInterval || simLoopCount == 0){            std::cout<<timeSinceStart.count()<<std::endl;            lastPrintTime = std::chrono::system_clock::now();        }                            simLoopCount++;    }        return 0;}void updateAeroAngles(){    alpha = aeroModel.getAlpha();    beta  = aeroModel.getBeta();}void updateBodyStates(){    p = pqr[0];    q = pqr[1];    r = pqr[2];        u = velBody[0];    v = velBody[1];    w = velBody[2];}