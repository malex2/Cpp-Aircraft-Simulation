//  Created by Alexander McLean on 08/09/19.//  Copyright Â© 2019 Alexander McLean. All rights reserved.#include <iostream>#include <chrono>#include <math.h>#include "RotateFrame.hpp"#include "AtmosphericModel.hpp"#include "GroundModel.hpp"#include "DynamicsModel.hpp"#include "AeroModel.hpp"#include "InitialConditions.h"AeroModel        aeroModel;GroundModel      groundModel;DynamicsModel    dynamicsModel;AtmosphericModel atmosphere;RotateFrame      rotate;int main() {        // Initialize body frame    rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, velBody, velNED);    rotate.RotateAngularRatesInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, pqr, omega);    updateBodyStates();        // Initialize alpha and beta    aeroModel.Angles(velBody);    updateAeroAngles();    // Start realtime clock    std::chrono::time_point<std::chrono::system_clock> startTime, curTime, lastPrintTime, lastDynamicTime;    startTime        = std::chrono::system_clock::now();    lastPrintTime    = startTime;    lastDynamicTime  = startTime;        while(continueSim){                // Evaluate Time Elapsed        curTime = std::chrono::system_clock::now();        std::chrono::duration<double> timeSinceStart        = curTime - startTime;        std::chrono::duration<double> timeSinceLastPrint    = curTime - lastPrintTime;        std::chrono::duration<double> timeSinceLastDynamics = curTime - lastDynamicTime;                // Evaluate stop conditions        if (timeSinceStart.count() >= runTime || stopSimGround) {            continueSim = false;        }                if (timeSinceLastDynamics.count() >= dynamicsInterval){            lastDynamicTime = std::chrono::system_clock::now();                        // Get forces and moments            atmosphere.gravityModel(mass, elevation, altTruth, FgravityNED);            aeroModel.rcPlane(pqr, actuators, FaeroWind, MaeroBody);                        // Rotate forces and moments to body frame            rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, FgravityBody, FgravityNED);            rotate.RotateInertialToBody(0, alpha*deg2rad, -beta*deg2rad, FaeroBody, FaeroWind);                        FaeroBody[0] += throttle*maxThrust;                        // Compute ground forces            stopSimGround = groundModel.flatGround(altTruth, mass, attitude, omega, velBody, FaeroBody, FgroundBody, MgroundBody);                        // Sum forces            dynamicsModel.sumForces(sumForce, FaeroBody, FgroundBody, FgravityBody);            dynamicsModel.sumForces(sumMoment, MaeroBody, MgroundBody, MgravityBody);                        // F = ma in body frame and solve for pqr, uvw            dynamicsModel.dynamics(velBody, pqr, sumForce, sumMoment, inertia, mass, dynamicsInterval);                        // Update uvw, pqr, and aero angles            updateBodyStates();            updateAeroAngles();                        // Rotate body states into world frame            rotate.RotateBodyToInertial(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, velBody, velNED);            rotate.RotateAngularRatesBodyToInertial(phiTruth*deg2rad, thetaTruth*deg2rad, pqr, omega);        }                // Print stuff        if (timeSinceLastPrint.count() >= printInterval || simLoopCount == 0){            std::cout<<timeSinceStart.count()<<std::endl;            std::cout<<simLoopCount<<std::endl;            lastPrintTime = std::chrono::system_clock::now();        }                        simLoopCount++;    }        return 0;}void updateAeroAngles(){    alpha = aeroModel.getAlpha();    beta  = aeroModel.getBeta();}void updateBodyStates(){    p = pqr[0];    q = pqr[1];    r = pqr[2];        u = velBody[0];    v = velBody[1];    w = velBody[2];}void updateWorldStates(){    phidotTruth   = omega[0];    thetadotTruth = omega[1];    psidotTruth   = omega[2];        xdotTruth    = velNED[0];    ydotTruth    = velNED[1];    zdotTruth    = velNED[2];}