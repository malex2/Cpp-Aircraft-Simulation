//  Created by Alexander McLean on 08/09/19.//  Copyright Â© 2019 Alexander McLean. All rights reserved.#include <iostream>#include <chrono>#include <math.h>#include "RotateFrame.hpp"#include "AtmosphericModel.hpp"#include "GroundModel.hpp"#include "DynamicsModel.hpp"#include "AeroModel.hpp"#include "InitialConditions.h"AeroModel        aeroModel;GroundModel      groundModel;DynamicsModel    dynamicsModel;AtmosphericModel atmosphere;RotateFrame      rotate;int main() {        // Initialize body frame    rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, velBody, velNED);    rotate.RotateAngularRatesInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, pqr, omega);    updateBodyStates();        // Initialize alpha and beta    aeroModel.Angles(velBody);    updateAeroAngles();    // Start realtime clock    std::chrono::time_point<std::chrono::system_clock> startTime, curTime, lastPrintTime, lastDynamicTime;    startTime        = std::chrono::system_clock::now();    lastPrintTime    = startTime;    lastDynamicTime  = startTime;        while(continueSim){                // Evaluate Time Elapsed        curTime = std::chrono::system_clock::now();        std::chrono::duration<double> timeSinceStart        = curTime - startTime;        std::chrono::duration<double> timeSinceLastPrint    = curTime - lastPrintTime;        std::chrono::duration<double> timeSinceLastDynamics = curTime - lastDynamicTime;                // Evaluate stop conditions        if (timeSinceStart.count() >= runTime || stopSimGround) {            continueSim = false;        }                if (timeSinceLastDynamics.count() >= dynamicsInterval){            lastDynamicTime = std::chrono::system_clock::now();                        // Get forces and moments            atmosphere.gravityModel(mass, elevation, altTruth, FgravityNED);                        aeroModel.Angles(velBody);            aeroModel.rcPlane(pqr, actuators, FaeroWind, MaeroBody);                        // Rotate forces and moments to body frame            rotate.RotateInertialToBody(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, FgravityBody, FgravityNED);            rotate.RotateInertialToBody(0, alpha*deg2rad, -beta*deg2rad, FaeroBody, FaeroWind);                        FaeroBody[0] += throttle*maxThrust;                        // Compute ground forces            stopSimGround = groundModel.flatGround(altTruth, mass, attitude, omega, velBody, FaeroBody, FgroundBody, MgroundBody);                        // Sum forces            dynamicsModel.sumForces(sumForce, FaeroBody, FgroundBody, FgravityBody);            dynamicsModel.sumForces(sumMoment, MaeroBody, MgroundBody, MgravityBody);                        // F = ma in body frame, update pqr and uvw            dynamicsModel.dynamics(velBody, pqr, sumForce, sumMoment, inertia, mass, dynamicsInterval);            updateBodyStates();            updateAeroAngles();                        // Rotate body frame state rates into world frame state rates            rotate.RotateBodyToInertial(phiTruth*deg2rad, thetaTruth*deg2rad, psiTruth*deg2rad, velBody, velNED);            rotate.RotateAngularRatesBodyToInertial(phiTruth*deg2rad, thetaTruth*deg2rad, pqr, omega);                        // Get world position and attitude            dynamicsModel.integrate(posNED, attitude, velBody, omega, dynamicsInterval);            updateWorldStates();        }                // Print stuff        if (timeSinceLastPrint.count() >= printInterval || simLoopCount == 0){                        std::cout<<"Time"<<": "<<timeSinceStart.count()<<"\n";                        std::cout<<"Position"<<"\n";            std::cout<<xTruth<<" "<<yTruth<<" "<<altTruth<<" "<<"\n";                        std::cout<<"Velocity"<<"\n";            std::cout<<xdotTruth<<" "<<ydotTruth<<" "<<zdotTruth<<" "<<"\n";                        std::cout<<"Pitch"<<"\n";            std::cout<<phiTruth<<" "<<thetaTruth<<" "<<psiTruth<<"\n";               std::cout<<"Aero Angles"<<"\n";            std::cout<<alpha<<" "<<beta<<"\n\n";                        lastPrintTime = std::chrono::system_clock::now();        }                        simLoopCount++;    }        return 0;}void updateAeroAngles(){    alpha = aeroModel.getAlpha();    beta  = aeroModel.getBeta();}void updateBodyStates(){    u = velBody[0];    v = velBody[1];    w = velBody[2];        p = pqr[0];    q = pqr[1];    r = pqr[2];}void updateWorldStates(){    xTruth        = posNED[0];    yTruth        = posNED[1];    zTruth        = posNED[2];    altTruth      = -zTruth;        phiTruth      = attitude[0];    thetaTruth    = attitude[1];    psiTruth      = attitude[2];        phidotTruth   = omega[0];    thetadotTruth = omega[1];    psidotTruth   = omega[2];        xdotTruth     = velNED[0];    ydotTruth     = velNED[1];    zdotTruth     = velNED[2];}